/* -*-java-*-
PropertyListView.java
 *
 *    Copyright (c) 2005 by Benja Fallenstein
 *
 *    This file is part of Fenfire.
 *    
 *    Fenfire is free software; you can redistribute it and/or modify it under
 *    the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *    
 *    Fenfire is distributed in the hope that it will be useful, but WITHOUT
 *    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 *    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
 *    Public License for more details.
 *    
 *    You should have received a copy of the GNU General
 *    Public License along with Fenfire; if not, write to the Free
 *    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
 *    MA  02111-1307  USA
 *
 */
/*
 * Written by Benja Fallenstein
 */
package org.fenfire.view;
import org.fenfire.Cursor;
import org.fenfire.swamp.*;
import org.fenfire.vocab.RDF;
import org.fenfire.vocab.RSS;
import org.nongnu.libvob.VobScene;
import org.nongnu.libvob.fn.*;
import org.nongnu.libvob.lob.*;
import org.nongnu.libvob.lob.lobs.*;
import javolution.realtime.*;
import javolution.util.*;
import java.awt.Color;
import java.util.*;

public class PropertyListView implements SpatialView {
    private static final void p(String s) { System.out.println("PropertyListReprView:: "+s); }

    /** Viewlet is a small view that renders a property of a node */
    public interface Viewlet {
	boolean canRender(Graph graph, Object prop, Object node);
	Lob getLob(Graph graph, ReprView reprView, Cursor cursor, 
		   Object prop, Object node);
    }

    /** Simple viewlet shows any property using the representation view */
    public static class SimpleViewlet implements Viewlet {
	public boolean canRender(Graph graph, Object prop, Object node) {
	    return 
		graph.findN_X11_Iter(prop, node).hasNext() ||
		graph.findN_11X_Iter(node, prop).hasNext();
	}

	private Lob valueLob(Cursor cursor, ReprView reprView, Object value) {
	    Lob l = reprView.getLob(value);
	    l = Lobs.clickController(l, 1, new @realtime-i Action(Cursor cursor, Object value) {
		public void run() {
		    cursor.set(value);
		    
		    VobScene sc = ClickController.getClickScene();
		    int cs = ClickController.getClickCS();
		    
		    ConnectionVobMatcher m = (ConnectionVobMatcher)sc.matcher;
			m.setNextFocus(cs);
		}
	    });
	    l = BuoyConnectorLob.newInstance(l, value, false, false);
	    l = Lobs.noGrow(Axis.Y, l);
	    return Components.frame(l, Maps.map("clip", Boolean.FALSE));
	}
	
	public Lob getLob(Graph graph, ReprView reprView, Cursor cursor,
			  Object prop, Object node) {

	    LobFont font = Components.font();

	    boolean 
		hasLeftValues = graph.findN_X11_Iter(prop, node).hasNext(),
		hasRightValues = graph.findN_11X_Iter(node, prop).hasNext();

	    Lob leftLabel = Lobs.hbox(Lists.concat(font.text("Inverse "),
						   reprView.getLobList(prop),
						   font.textLn(":")));
	    Lob rightLabel = Lobs.hbox(Lists.concat(reprView.getLobList(prop),
						    font.textLn(":")));

	    Lob vbox = Lobs.vbox();
	    vbox.add(leftLabel); vbox.add(Lobs.vglue());
	    leftLabel = vbox;

	    vbox = Lobs.vbox();
	    vbox.add(rightLabel); vbox.add(Lobs.vglue());
	    rightLabel = vbox;


	    vbox = Lobs.vbox();

	    Iterator 
		iter_left  = graph.findN_X11_Iter(prop, node),
		iter_right = graph.findN_11X_Iter(node, prop);

	    boolean isFirst = true;

	    while(iter_left.hasNext() || iter_right.hasNext()) {

		if(!isFirst)
		    vbox.add(Lobs.glue(Axis.Y, 2, 2, 2));

		Lob hbox = Lobs.hbox();

		Cursor.Rotation leftRotation, rightRotation;
		Lob left, right;
		Lob llabel, rlabel;
		
		if(iter_left.hasNext()) {
		    Object value = iter_left.next();

		    left = valueLob(cursor, reprView, value);
		    llabel = isFirst ? leftLabel : Lobs.nullLob();
		    leftRotation = new Cursor.Rotation(prop, value, -1);
		} else {
		    left = llabel = Lobs.nullLob();
		    leftRotation = null;
		}
		
		if(iter_right.hasNext()) {
		    Object value = iter_right.next();

		    right = valueLob(cursor, reprView, value);
		    rlabel = isFirst ? rightLabel : Lobs.nullLob();
		    rightRotation = new Cursor.Rotation(prop, value, 1);
		} else {
		    right = rlabel = Lobs.nullLob();
		    rightRotation = null;
		}

		hbox.add(Lobs.request(Axis.X, llabel, 0, 0, 2*Lob.INF/3));
		hbox.add(Lobs.request(Axis.X, left, 0, 0, Lob.INF));
		hbox.add(Lobs.glue(Axis.X, 15, 15, 15));
		hbox.add(Lobs.request(Axis.X, rlabel, 0, 0, 2*Lob.INF/3));
		hbox.add(Lobs.request(Axis.X, right, 0, 0, Lob.INF));

		Lob lob = hbox;

		if(leftRotation != null) {
		    Lob keylob = Lobs.key(Lobs.nullLob(), leftRotation);
		    lob = Lobs.between(keylob, lob, null);
		}

		if(rightRotation != null) {
		    Lob keylob = Lobs.key(Lobs.nullLob(), rightRotation);
		    lob = Lobs.between(keylob, lob, null);
		}

		lob = Lobs.clickController(lob, 1, new @realtime-i Action(Cursor cursor, Object node, Cursor.Rotation leftRotation, Cursor.Rotation rightRotation) {
		    public void run() {
			if(rightRotation != null) {
			    cursor.setRotation(node, rightRotation);
			} else if(leftRotation != null) {
			    cursor.setRotation(node, leftRotation);
			}
		    }
		});

		vbox.add(lob);

		isFirst = false;
	    }

	    return Lobs.noGrow(Axis.Y, vbox);
	}
    }

    /** Body viewlet shows content of a big property such as a message body. */
    public static class BodyViewlet implements Viewlet {
	public boolean canRender(Graph graph, Object prop, Object node) {
	    // XXX more "body" properties?
	    if (prop != RSS.description && prop != RSS.encoded)
		return false;
	    if (graph.findN_X11_Iter(prop, node).hasNext())
		return false; // we won't show reverse properties
	    Iterator i = graph.findN_11X_Iter(node, prop); 
	    if (!i.hasNext())
		return false;
	    Object body = i.next();
	    if (i.hasNext())
		return false; // we won't show more than the body

	    return (body instanceof Literal);
	}

	public Lob getLob(Graph graph, ReprView reprView, Cursor cursor,
			  Object prop, Object node) {
	    // Don't show rss:description if there's content:encoded too
	    if (prop == RSS.description &&
		graph.findN_11X_Iter(node, RSS.encoded).hasNext())
		return Lobs.nullLob();

	    Lob vbox = Lobs.vbox();

	    Lob lob = Lobs.hbox(reprView.getLobList(prop));

	    Lob hbox = Lobs.hbox();
	    hbox.add(lob);
	    hbox.add(Lobs.hglue());

	    vbox.add(hbox);

	    hbox = Lobs.hbox();
	    Lob rightValues = Components.frame(Lobs.vbox(), 
					      Maps.map("clip", Boolean.FALSE));
	    hbox.add(Lobs.request(Axis.X, rightValues, 0, 0, Lob.INF));

	    vbox.add(hbox);

	    Literal value = (Literal) graph.find1_11X(node, prop);

	    String body = value.getString();
	    List list = Lists.list(body);
	    Lob l = Lobs.linebreaker(Components.font().textLn(body));
	    rightValues.add(l);

	    rightValues.add(Lobs.vglue());

	    return Lobs.noGrow(Axis.Y, vbox);
	}
    }

    /** Container viewlet shows a list of elements instead of the container.
     */
    public static class ContainerViewlet implements Viewlet {
	private Object reverseProperty(Graph graph, Object prop, 
					 Object node) {
	    // XXX the rest of URI should be integer without leading zeros
	    if (!prop.toString().startsWith(RDF.voc_))
		return null; // we only show containment properties

	    if (graph.findN_11X_Iter(node, prop).hasNext())
		return null; // we won't show forward properties
	    Iterator i = graph.findN_X11_Iter(prop, node); 
	    if (!i.hasNext())
		return null;
	    Object container = i.next();
	    if (i.hasNext())
		return null; // we won't show more than one container

	    Iterator j = graph.findN_AX1_Iter(container);
	    if (!j.hasNext())
		return null;
	    Object reverseProperty = j.next();
	    if (j.hasNext())
		return null; // we won't show more than one container

	    Iterator k = graph.findN_X11_Iter(reverseProperty, container);
	    if (!k.hasNext())
		return null;
	    Object source = k.next();
	    if (k.hasNext())
		return null; // we won't show more than one container
	    
	    // XXX container can have additional properties that we don't show
	    return reverseProperty; // OK
	}

	public boolean canRender(Graph graph, Object prop, Object node) {
	    if (reverseProperty(graph, prop, node) != null)
		return true;

	    if (graph.findN_X11_Iter(prop, node).hasNext())
		return false; // we won't show reverse properties
	    Iterator i = graph.findN_11X_Iter(node, prop); 
	    if (!i.hasNext())
		return false;
	    Object container = i.next();
	    if (i.hasNext())
		return false; // we won't show more than the container

	    // XXX there can be additional properties that we don't show or
	    // container properties after we stop showing
	    return graph.findN_11X_Iter(container, RDF._1).hasNext();
	}

	public Lob getReverseLob(Graph graph, ReprView reprView, Cursor cursor,
			  Object reverseProperty, Object container) {
	    Object source = graph.find1_X11(reverseProperty, container);

	    LobFont font = Components.font();

	    Lob leftLabel = Lobs.hbox(Lists.concat(font.text("One in "),
						   reprView.getLobList(
						       reverseProperty),
						   font.textLn(" of:")));
	    Lob vbox = Lobs.vbox();
	    vbox.add(leftLabel); vbox.add(Lobs.vglue());
	    leftLabel = vbox;

	    Lob left = Components.frame(reprView.getLob(source));


	    Lob hbox = Lobs.hbox();

	    hbox.add(Lobs.request(Axis.X, leftLabel, 0, 0, 2*Lob.INF/3));
	    hbox.add(Lobs.request(Axis.X, left, 0, 0, Lob.INF));
	    hbox.add(Lobs.request(Axis.X, Lobs.nullLob(), 0, 0, 5*Lob.INF/3));

	    return Lobs.noGrow(Axis.Y, hbox);
	}

	public Lob getLob(Graph graph, ReprView reprView, Cursor cursor,
			  Object prop, Object node) {
	    Object reverseProperty = reverseProperty(graph, prop, node);
	    if (reverseProperty != null)
		return getReverseLob(graph, reprView, cursor, reverseProperty, 
				     graph.find1_X11(prop, node));

	    Lob vbox = Lobs.vbox();

	    Lob lob = Lobs.hbox(reprView.getLobList(prop));

	    Lob hbox = Lobs.hbox();
	    hbox.add(lob);
	    hbox.add(Lobs.hglue());

	    vbox.add(hbox);

	    hbox = Lobs.hbox();
	    Lob rightValues = Components.frame(Lobs.vbox(), 
					      Maps.map("clip", Boolean.FALSE));
	    hbox.add(Lobs.request(Axis.X, rightValues, 0, 0, Lob.INF));

	    vbox.add(hbox);

	    Object container = graph.find1_11X(node, prop);

	    int itemnum=1;
	    while (true) {
		Object itemprop = Nodes.get(RDF.voc+'_'+itemnum);
		Iterator j=graph.findN_11X_Iter(container, itemprop);
		if (!j.hasNext())
		    break; // end of continuous part of the list
		while (j.hasNext()) {
		    Object item = j.next();
		    Lob l = reprView.getLob(item);
		    l = Lobs.clickController(l, 1, 
			   new @realtime-i Action(Cursor cursor, Object item) {
			public void run() {
			    cursor.set(item);
					
			    VobScene sc = ClickController.getClickScene();
			    int cs = ClickController.getClickCS();
					
			    ConnectionVobMatcher m = 
			        (ConnectionVobMatcher) sc.matcher;
			    m.setNextFocus(cs);
			}
		    });
		    l = BuoyConnectorLob.newInstance(l, item, false, false);
				
		    rightValues.add(l);
				
		}
		itemnum++; // next item property
	    }
	    rightValues.add(Lobs.vglue());

	    return Lobs.noGrow(Axis.Y, vbox);
	}
    }
    
    Graph graph;
    List properties;
    List viewlets;
    ReprView reprView;

    public PropertyListView(Graph graph, List properties,
			    List viewlets, ReprView reprView) {
	this.graph = graph;
	this.properties = properties;
	this.viewlets = viewlets;
	this.reprView = reprView;
    }

    public Set getTypes() {
	return Collections.singleton(ViewSettings.ALL);
    }

    public Lob getMainviewLob(Cursor cursor) {
	Object node = cursor.getNode();

	List lobs = new @realtime RealtimeList(Cursor cursor, Object node,
					       List properties, List viewlets,
					       Graph graph, ReprView reprView){
	    public int size() {
		return properties.size();
	    }

	    public Object get(int i) {
		Object prop = properties.get(i);
		
		for(Iterator iter = viewlets.iterator(); iter.hasNext();) {
		    Viewlet v = (Viewlet)iter.next();
		    if(v.canRender(graph, prop, node)) {
			Lob l = v.getLob(graph, reprView, cursor, prop, node);

			Lob vbox = Lobs.vbox();
			vbox.add(l);
			vbox.add(Lobs.glue(Axis.Y, 5, 5, 5));

			return vbox;
		    }
		}

		// no viewlet can render this, so we don't render it
		return Lobs.glue(Axis.Y, 0, 0, 0);
	    }
	};

	Lob title = Lobs.scale(reprView.getLob(node), 1.5f);
	title = BuoyConnectorLob.newInstance(title, node, true, false);
	title = Lobs.request(Axis.X, title, -1, -1, SizeRequest.INF);
	title = Lobs.noGrow(Axis.Y, title);

	Lob hbox = Lobs.hbox();
	hbox.add(Lobs.hglue());
	hbox.add(title);
	hbox.add(Lobs.hglue());

	Lob vbox = Lobs.vbox();
	vbox.add(hbox);
	vbox.add(Lobs.glue(Axis.Y, 15, 15, 15));
	vbox.add(Lobs.vbox(lobs));
	vbox.add(Lobs.vglue());

	Object rotation = cursor.getRotation(node);

        Lob cursor_lob = Lobs.filledRect(Components.darkColor);
        cursor_lob = Lobs.key(cursor_lob, "cursor");

	Lob lob = vbox;
        lob = Lobs.decorate(lob, cursor_lob, rotation, -1, 0);
	lob = Lobs.viewport(Axis.Y, lob, rotation, -1);
	lob = Lobs.request(Axis.Y, lob, 0, 0, -1);

	FastMap keys = FastMap.newInstance();
	PropertyListView view = this;
	keys.put("Up", new @realtime-i Action(Cursor cursor, PropertyListView view) {
	    public void run() {
		view.scroll(cursor, -1);
	    }
	});
	keys.put("Down", new @realtime-i Action(Cursor cursor, PropertyListView view) {
	    public void run() {
		view.scroll(cursor, 1);
	    }
	});
	keys.put("Left", new @realtime-i Action(Cursor cursor, PropertyListView view) {
	    public void run() {
		view.move(cursor, -1);
	    }
	});
	keys.put("Right", new @realtime-i Action(Cursor cursor, PropertyListView view) {
	    public void run() {
		view.move(cursor, 1);
	    }
	});

	lob = Lobs.keyController(lob, keys);

	return Components.frame(SpatialContextLob.newInstance(lob, node));
    }

    public Lob getBuoyLob(Object node, boolean useFakeFocus) {
	Lob l = Components.frame(reprView.getLob(node));
	l = BuoyConnectorLob.newInstance(l, node, !useFakeFocus, useFakeFocus);
	l = SpatialContextLob.newInstance(l, node);
	return l;
    }

    void move(Cursor cursor, int dir) {
	Object oldNode = cursor.getNode();

	Cursor.Rotation r = cursor.getRotation();
	Object prop = r.getRotationProperty();

	List conns = getConnectionList(oldNode, prop, r.getRotationDir());
	int index = indexOf(conns, r.getRotationNode());

	if(index < 0) return; // XXX

	conns = getConnectionList(oldNode, prop, dir);
	if(index >= conns.size()) return; // no such connection, do nothing
	Object node = conns.get(index);

	cursor.setRotation(node, prop, oldNode, -dir);
	cursor.set(node);
    }

    void scroll(Cursor cursor, int dir) {
	Object node = cursor.getNode();

	Cursor.Rotation r = cursor.getRotation();

	Object prop = r.getRotationProperty();
	Object value = r.getRotationNode();
	int rdir = r.getRotationDir();

	List conns = getConnectionList(node, prop, rdir);
	int index = indexOf(conns, value);
	if(index < 0) return; // XXX

	index += dir;
	
	if(index >= 0 && index < conns.size()) {
	    cursor.setRotation(node, prop, conns.get(index), rdir);
	    return;
	}

	conns = getConnectionList(node, prop, -rdir);

	if(index >= 0 && index < conns.size()) {
	    cursor.setRotation(node, prop, conns.get(index), -rdir);
	    return;
	}

	int pindex = indexOf(properties, prop);
	if(pindex < 0) {
	    return; // XXX
	}

	List left, right;

	do {
	    pindex += dir;

	    if(pindex < 0)
		return; // we're already at the top, can't go up more

	    if(pindex >= properties.size())
		return; // we're already at the bottom, can't go down more

	    prop = properties.get(pindex);
	
	    left = getConnectionList(node, prop, -1);
	    right = getConnectionList(node, prop, 1);

	    if(left.size() == 0 && right.size() == 0)
		continue;

	    if(dir > 0) {
		if(right.size() > 0) {
		    cursor.setRotation(node, prop, right.get(0), 1);
		} else if(left.size() > 0) {
		    cursor.setRotation(node, prop, left.get(0), -1);
		} else {
		    continue;
		}
	    } else {
		if(left.size() > right.size()) {
		    cursor.setRotation(node, prop, left.get(left.size()-1), -1);
		} else if(right.size() > 0) {
		    cursor.setRotation(node, prop, right.get(right.size()-1), 1);
		} else {
		    continue;
		}
	    }

	    break;
	} while(true);
    }

    int indexOf(List l, Object o) {
	// argl, seems like Javolution's indexOf implementation is buggy...

	for(int i=0; i<l.size(); i++)
	    if(l.get(i).equals(o)) return i;

	return -1;
    }

    List getConnectionList(Object node, Object prop, int dir) {
	List list = Lists.list();

	Iterator i = (dir > 0) ? graph.findN_11X_Iter(node, prop)
	                       : graph.findN_X11_Iter(prop, node);

	while(i.hasNext()) 
	    list.add(i.next());

	return list;
    }
}
